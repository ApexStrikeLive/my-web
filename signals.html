<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trade Signals Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Minimalist Global Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #334155; /* Darker text color */
            padding: 1rem;
        }
        .container {
            max-width: 1200px; /* Wider for TradingView */
            margin: 1rem auto;
            background-color: #ffffff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        h1 {
            font-size: 2rem;
            text-align: center;
            color: #1e40af;
            margin-bottom: 1.5rem;
        }

        /* Summary Statistics Styles */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background-color: #e0f2fe;
            border-radius: 0.25rem;
        }
        .stat-item {
            background-color: #ffffff;
            border-radius: 0.25rem;
            padding: 0.75rem;
            text-align: center;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .stat-item p {
            font-size: 0.875rem;
            font-weight: 500;
            color: #475569;
        }
        .stat-item span {
            font-size: 1.25rem;
            font-weight: bold;
        }
        .green-text { color: #16a34a; }
        .red-text { color: #dc2626; }
        .blue-text { color: #2563eb; }
        .purple-text { color: #9333ea; }
        .orange-text { color: #ea580c; }

        /* Date Section Styles */
        .date-section {
            margin-bottom: 1rem;
            border: 1px solid #bfdbfe;
            border-radius: 0.5rem;
            background-color: #ffffff;
        }
        .date-summary {
            background-color: #dbeafe;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem 0.5rem 0 0;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1rem;
            color: #1e40af;
            display: block;
        }
        details[open] .date-summary {
            border-radius: 0.5rem 0.5rem 0 0;
        }
        
        /* Signal Card Styles (minimalist) */
        .signal-card {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0; /* Separator between signals */
            margin-bottom: 1rem;
        }
        .signal-card:last-child {
            border-bottom: none; /* No border for the last card */
            margin-bottom: 0;
        }
        .signal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        .signal-header h2 {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
        }
        .signal-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); /* Adjust for info density */
            gap: 0.5rem;
            font-size: 0.875rem;
            margin-bottom: 0.75rem;
        }
        .signal-info-item strong {
            color: #475569;
            margin-right: 0.25rem;
        }
        .buy-signal-text { color: #10b981; font-weight: bold; }
        .sell-signal-text { color: #ef4444; font-weight: bold; }
        .status-open { background-color: #bfdbfe; color: #1e40af; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; }
        .status-closed { background-color: #e2e8f0; color: #475569; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; }
        
        /* TradingView Chart Styles */
        .chart-container {
            margin-top: 1rem;
            background-color: #f8fafc;
            padding: 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid #e2e8f0;
            height: 350px; /* Fixed height for consistency and lightness */
            overflow: hidden;
            display: flex; /* Use flex to manage inner widget */
            flex-direction: column;
        }
        .tradingview-widget-container__widget {
            flex-grow: 1; /* Allow widget to take available space */
            height: 100%; /* Important for widget to fill container */
        }
        .tradingview-widget-copyright {
            font-size: 0.7rem;
            color: #787b86;
            text-align: right;
            padding-top: 0.25rem;
        }
        .tradingview-widget-copyright a {
            color: #787b86;
            text-decoration: none;
        }
        .tradingview-widget-copyright a:hover {
            text-decoration: underline;
        }

        /* Take Profit Table Styles */
        .tp-table-wrapper {
            overflow-x: auto;
            margin-top: 0.75rem;
            margin-bottom: 1rem;
        }
        .tp-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem; /* Very small font for TP table */
        }
        .tp-table th, .tp-table td {
            padding: 0.4rem 0.6rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            white-space: nowrap; /* Prevent wrapping in TP table cells */
        }
        .tp-table th {
            background-color: #f0f4f8;
            font-weight: 600;
            color: #64748b;
        }
        .tp-table tr:hover {
            background-color: #f8fafc;
        }
        .tp-achieved {
            background-color: #dcfce7; /* Light green background for achieved TP */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trade Signals Overview</h1>

        <div class="stats-grid">
            <div class="stat-item">
                <p>Total Signals:</p>
                <span id="totalSignals">0</span>
            </div>
            <div class="stat-item">
                <p>Successful:</p>
                <span id="successfulSignals" class="green-text">0</span>
            </div>
            <div class="stat-item">
                <p>Unsuccessful:</p>
                <span id="closedUnsuccessfulSignals" class="red-text">0</span>
            </div>
            <div class="stat-item">
                <p>Open Signals:</p>
                <span id="openSignals" class="blue-text">0</span>
            </div>
            <div class="stat-item">
                <p>Closed 100%:</p>
                <span id="totalClosed100Percent" class="purple-text">0</span>
            </div>
            <div class="stat-item">
                <p>SL (Loss > -3%):</p>
                <span id="closedSLLossGreaterThan3" class="orange-text">0</span>
            </div>
        </div>

        <div id="signalsContainer">
            <p class="text-center text-gray-500 py-4">Loading trade signals...</p>
        </div>
    </div>

    <script>
        let charts = {}; // To manage TradingView widgets

        // Definition for Take Profit levels
        const tpLevelsDefinition = [
            { level: 0.7, close_percentage: 25 },
            { level: 0.8, close_percentage: 0 },
            { level: 1.2, close_percentage: 25 },
            { level: 1.5, close_percentage: 0 },
            { level: 1.8, close_percentage: 0 },
            { level: 2.0, close_percentage: 25 },
            { level: 2.4, close_percentage: 0 },
            { level: 2.6, close_percentage: 0 },
            { level: 2.8, close_percentage: 0 },
            { level: 3.0, close_percentage: 0 },
            { level: 3.3, close_percentage: 100 }
        ];

        const formatNumber = (value, decimals) => {
            return (typeof value === 'number' && !isNaN(value)) ? value.toFixed(decimals) : 'N/A';
        };

        const formatPercentage = (value) => {
            return (typeof value === 'number' && !isNaN(value)) ? `${value.toFixed(2)}%` : 'N/A';
        };

        async function fetchSignals() {
            try {
                const githubUrl = 'https://raw.githubusercontent.com/ApexStrikeLive/my-web/main/traced_signals.json';
                console.log("Fetching historical data...");
                const response = await fetch(githubUrl);
                
                let fetchedData = [];
                if (response.ok) {
                    fetchedData = await response.json();
                    console.log("Historical data fetched:", fetchedData.length, "signals.");
                } else {
                    console.error(`Error fetching historical data! Status: ${response.status}`);
                    return [];
                }

                const mergedData = {};
                fetchedData.forEach(signal => mergedData[signal.signal_id] = signal);

                // --- Live price fetching ---
                const coinGeckoIdMap = {
                    "BTC": "bitcoin", "ETH": "ethereum", "ADA": "cardano", "CVX": "convex-finance",
                    "APT": "aptos", "METIS": "metisdao", "GAS": "gas", "SSV": "ssv-network",
                    "AAVE": "aave", "LINK": "chainlink", "SOL": "solana", "BNB": "binancecoin",
                    "ORDI": "ordi", "CYBER": "cyberconnect", "MOVR": "moonriver", "GNO": "gnosis",
                    "LPT": "livepeer", "ATM": "atletico-madrid-fan-token", "DCR": "decred", "PSG": "paris-saint-germain-fan-token",
                };

                const symbolsToFetch = new Set();
                Object.values(mergedData).forEach(signal => {
                    const baseSymbol = signal.symbol ? signal.symbol.split('/')[0] : null;
                    if (baseSymbol && coinGeckoIdMap[baseSymbol]) {
                        symbolsToFetch.add(coinGeckoIdMap[baseSymbol]);
                    }
                });

                if (symbolsToFetch.size > 0) {
                    const ids = Array.from(symbolsToFetch).join(',');
                    const vsCurrencies = 'usdt';
                    const livePriceUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=${vsCurrencies}`;
                    console.log("Fetching live prices...");
                    try {
                        const priceResponse = await fetch(livePriceUrl);
                        if (priceResponse.ok) {
                            const livePrices = await priceResponse.json();
                            Object.values(mergedData).forEach(signal => {
                                const baseSymbol = signal.symbol ? signal.symbol.split('/')[0] : null;
                                const coinGeckoId = baseSymbol ? coinGeckoIdMap[baseSymbol] : null;
                                if (coinGeckoId && livePrices[coinGeckoId] && livePrices[coinGeckoId][vsCurrencies]) {
                                    const newCurrentPrice = livePrices[coinGeckoId][vsCurrencies];
                                    signal.current_price = newCurrentPrice;

                                    if (signal.monitoring_status === 'OPEN' && typeof signal.entry_price === 'number' && signal.entry_price !== 0) {
                                        if (signal.signal_type === 'BUY') {
                                            signal.profit_loss_percentage = ((newCurrentPrice - signal.entry_price) / signal.entry_price) * 100;
                                            signal.unrealized_pnl = (newCurrentPrice - signal.entry_price) * (signal.initial_investment / signal.entry_price);
                                        } else if (signal.signal_type === 'SELL') {
                                            signal.profit_loss_percentage = ((signal.entry_price - newCurrentPrice) / newCurrentPrice) * 100;
                                            signal.unrealized_pnl = (signal.entry_price - newCurrentPrice) * (signal.initial_investment / signal.entry_price);
                                        }
                                    } else if (signal.monitoring_status && signal.monitoring_status.includes('CLOSED')) {
                                        signal.unrealized_pnl = 0;
                                        if (typeof signal.realized_pnl === 'number' && typeof signal.initial_investment === 'number' && signal.initial_investment !== 0) {
                                            signal.profit_loss_percentage = (signal.realized_pnl / signal.initial_investment) * 100;
                                        } else {
                                            signal.profit_loss_percentage = 0;
                                        }
                                    }
                                }
                            });
                        } else {
                            console.warn(`Could not fetch live prices (status: ${priceResponse.status}).`);
                        }
                    } catch (priceError) {
                        console.error("Error fetching live prices:", priceError);
                    }
                } else {
                    console.log("No symbols for live price fetching.");
                }

                return Object.values(mergedData);

            } catch (error) {
                console.error("General error in fetchSignals:", error);
                return [];
            }
        }

        /**
         * Updates the summary statistics at the top of the page.
         */
        function updateSummaryStatistics(signals) {
            const totalSignals = signals.length;
            let successfulSignals = 0;
            let closedUnsuccessfulSignals = 0;
            let openSignals = 0;
            let totalClosed100Percent = 0;
            let closedSLLossGreaterThan3 = 0;

            signals.forEach(signal => {
                if (signal.monitoring_status === "OPEN") {
                    openSignals++;
                } else if (signal.monitoring_status && signal.monitoring_status.includes("CLOSED")) {
                    if (typeof signal.realized_pnl === 'number') {
                        if (signal.realized_pnl > 0) {
                            successfulSignals++;
                        } else {
                            closedUnsuccessfulSignals++;
                        }
                    } else {
                        closedUnsuccessfulSignals++;
                    }
                }

                if (typeof signal.closed_percentage === 'number' && signal.closed_percentage === 100 && signal.monitoring_status && signal.monitoring_status.includes('CLOSED')) {
                    totalClosed100Percent++;
                }

                if (signal.monitoring_status && signal.monitoring_status.includes("CLOSED_SL") &&
                    typeof signal.profit_loss_percentage === 'number' && signal.profit_loss_percentage < -3) {
                    closedSLLossGreaterThan3++;
                }
            });

            document.getElementById('totalSignals').textContent = totalSignals;
            document.getElementById('successfulSignals').textContent = successfulSignals;
            document.getElementById('closedUnsuccessfulSignals').textContent = closedUnsuccessfulSignals;
            document.getElementById('openSignals').textContent = openSignals;
            document.getElementById('totalClosed100Percent').textContent = totalClosed100Percent;
            document.getElementById('closedSLLossGreaterThan3').textContent = closedSLLossGreaterThan3;
        }

        /**
         * Creates and renders a TradingView chart for a given signal.
         */
        function createChart(signal, containerId) {
            const chartContainer = document.getElementById(containerId);
            if (!chartContainer) {
                console.error(`Chart container with ID ${containerId} not found.`);
                return;
            }
            chartContainer.innerHTML = ''; // Clear previous chart (if any)

            const [base, quote] = signal.symbol.split('/');
            const tradingViewSymbol = `BINANCE:${base}${quote}`;

            // Unique ID for the inner TradingView widget div
            const innerWidgetId = `tradingview_widget_${signal.signal_id}`;

            let tvInterval = "D"; // Default to Daily
            if (signal.timeframe && signal.timeframe.includes('m')) {
                tvInterval = signal.timeframe.replace('m', '');
            } else if (signal.timeframe && signal.timeframe.includes('h')) {
                tvInterval = signal.timeframe.replace('h', 'H');
            } else if (signal.timeframe === 'DAILY') {
                tvInterval = "D";
            }

            const script = document.createElement('script');
            script.type = 'text/javascript';
            script.src = 'https://s3.tradingview.com/external-embedding/embed-widget-advanced-chart.js';
            script.async = true;

            const widgetConfig = {
                "width": "100%",
                "height": "350", // Keep height consistent
                "symbol": tradingViewSymbol,
                "interval": tvInterval,
                "timezone": "Etc/UTC",
                "theme": "light",
                "style": "1",
                "locale": "en",
                "toolbar_bg": "#f1f5f9",
                "enable_publishing": false,
                "allow_symbol_change": true,
                "container_id": innerWidgetId, // Link to the specific container ID
                "hide_side_toolbar": false,
                "hide_top_toolbar": false,
                "withdateranges": true,
                "save_image": false,
                "details": false,
                "hotlist": false,
                "calendar": false,
                "studies": ["RSI@tv-basicstudies", "MACD@tv-basicstudies"],
                "show_popup_button": true,
                "popup_width": "1000",
                "popup_height": "650",
            };

            // TradingView requires a specific div structure
            const tradingViewHtml = `
                <div class="tradingview-widget-container" style="height:100%; width:100%;">
                    <div id="${innerWidgetId}" class="tradingview-widget-container__widget" style="height:calc(100% - 32px);width:100%;"></div>
                    <div class="tradingview-widget-copyright">
                        <a href="https://www.tradingview.com/" rel="noopener nofollow" target="_blank">
                            <span class="blue-text">Track all markets on TradingView</span>
                        </a>
                    </div>
                </div>
            `;
            chartContainer.innerHTML = tradingViewHtml; // Set the HTML structure

            // Append the script for the widget
            chartContainer.querySelector(`#${innerWidgetId}`).closest('.tradingview-widget-container').appendChild(script);

            // Set the script's textContent (config) after it's appended to ensure it's loaded properly
            // This needs to be done *after* the script element is added to the DOM and the TradingView library
            // is available, or use a callback mechanism if the script loads asynchronously.
            // For simplicity, we'll assign textContent directly, assuming TradingView handles it.
            script.textContent = JSON.stringify(widgetConfig);

            // Store chart reference (though directly manipulating DOM is more robust for TV)
            charts[signal.signal_id] = chartContainer;
        }


        /**
         * Renders the signals data into the HTML, grouped by date.
         */
        function renderSignals(signals) {
            const signalsContainer = document.getElementById('signalsContainer');
            signalsContainer.innerHTML = ''; // Clear previous content

            // Clear existing charts to prevent multiple instances from previous renders
            for (const id in charts) {
                if (charts[id]) {
                    charts[id].innerHTML = ''; // Clear the content of the chart container
                }
            }
            charts = {}; // Reset charts object for fresh rendering

            const sortedSignals = [...signals].sort((a, b) => new Date(b.entry_time) - new Date(a.entry_time));

            const signalsByDate = sortedSignals.reduce((acc, signal) => {
                const entryTime = signal.entry_time ? new Date(signal.entry_time) : null;
                const date = entryTime ? entryTime.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' }).replace(/\//g, '-') : 'Unknown Date';
                if (!acc[date]) {
                    acc[date] = [];
                }
                acc[date].push(signal);
                return acc;
            }, {});

            const now = new Date();
            // Important: Use the specific year from your data (2025) for 'Today' check
            // If the current actual year is different, 'Today' will not match unless you
            // adjust your system clock or the data's year to the current year.
            const todayDateString = "2025-07-28"; // Manually set to match your data for consistency

            // If you want "Today" to match the actual current date your machine sees:
            // const todayDateString = now.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' }).replace(/\//g, '-');


            for (const date in signalsByDate) {
                const isToday = date === todayDateString;
                const detailsElement = document.createElement('details');
                detailsElement.className = 'date-section';

                // Open today's signals by default, or the latest date if not today
                if (isToday || (Object.keys(signalsByDate).indexOf(date) === 0 && Object.keys(signalsByDate).length > 1)) {
                     detailsElement.setAttribute('open', '');
                } else if (Object.keys(signalsByDate).length === 1) { // If only one date, open it
                    detailsElement.setAttribute('open', '');
                }

                const summaryElement = document.createElement('summary');
                summaryElement.className = 'date-summary';
                summaryElement.textContent = `Signals for ${date}`;
                if (isToday) {
                    summaryElement.textContent += ' (Today)';
                }
                detailsElement.appendChild(summaryElement);

                const dateSignalsDiv = document.createElement('div');
                dateSignalsDiv.className = 'p-4'; // Simple padding for content

                const signalsForDate = signalsByDate[date];

                if (signalsForDate.length === 0) {
                    dateSignalsDiv.innerHTML = '<p class="text-center text-gray-600">No signals for this date.</p>';
                } else {
                    signalsForDate.forEach(signal => {
                        const signalCard = document.createElement('div');
                        signalCard.className = 'signal-card';
                        signalCard.id = `signal-${signal.signal_id}`;

                        const signalTypeClass = signal.signal_type === 'BUY' ? 'buy-signal-text' : 'sell-signal-text';
                        const pnlClass = (typeof signal.profit_loss_percentage === 'number' && !isNaN(signal.profit_loss_percentage)) ?
                            (signal.profit_loss_percentage >= 0 ? 'green-text' : 'red-text') : '';
                        const realizedPnlClass = (typeof signal.realized_pnl === 'number' && !isNaN(signal.realized_pnl)) ?
                            (signal.realized_pnl >= 0 ? 'green-text' : 'red-text') : '';
                        const statusClass = signal.monitoring_status === 'OPEN' ? 'status-open' : 'status-closed';

                        signalCard.innerHTML = `
                            <div class="signal-header">
                                <h2>${signal.symbol || 'N/A'} <span class="${signalTypeClass}">(${signal.signal_type || 'N/A'})</span></h2>
                                <span class="${statusClass}">${signal.monitoring_status || 'N/A'}</span>
                            </div>
                            <div class="signal-info-grid">
                                <div class="signal-info-item"><strong>Strategy:</strong> <span>${signal.strategy_name || 'N/A'}</span></div>
                                <div class="signal-info-item"><strong>Entry Price:</strong> <span>${formatNumber(signal.entry_price, 4)}</span></div>
                                <div class="signal-info-item"><strong>Current Price:</strong> <span>${formatNumber(signal.current_price, 4)}</span></div>
                                <div class="signal-info-item"><strong>Stop Loss:</strong> <span>${formatNumber(signal.stop_loss_price, 4)}</span></div>
                                <div class="signal-info-item"><strong>Entry Time:</strong> <span>${signal.entry_time ? new Date(signal.entry_time).toLocaleString() : 'N/A'}</span></div>
                                <div class="signal-info-item"><strong>Exit Time:</strong> <span>${signal.exit_time ? new Date(signal.exit_time).toLocaleString() : 'N/A'}</span></div>
                                <div class="signal-info-item"><strong>Timeframe:</strong> <span>${signal.timeframe || 'N/A'}</span></div>
                                <div class="signal-info-item"><strong>Initial Inv.:</strong> <span>$${formatNumber(signal.initial_investment, 2)}</span></div>
                                <div class="signal-info-item"><strong>P&L (%):</strong> <span class="${pnlClass}">${formatPercentage(signal.profit_loss_percentage)}</span></div>
                                <div class="signal-info-item"><strong>Unrealized PnL:</strong> <span class="${pnlClass}">$${formatNumber(signal.unrealized_pnl, 2)}</span></div>
                                <div class="signal-info-item"><strong>Realized PnL:</strong> <span class="${realizedPnlClass}">$${formatNumber(signal.realized_pnl, 2)}</span></div>
                                <div class="signal-info-item"><strong>Closed %:</strong> <span>${formatNumber(signal.closed_percentage, 0)}%</span></div>
                            </div>

                            <h4 class="text-sm font-semibold mt-4 mb-2 text-gray-700">Take Profit Levels:</h4>
                            <div class="tp-table-wrapper">
                                <table class="tp-table">
                                    <thead>
                                        <tr>
                                            <th>Level</th>
                                            <th>Price</th>
                                            <th>Profit (%)</th>
                                            <th>Reached</th>
                                            <th>Closed %</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${tpLevelsDefinition.map(tp => {
                                            const tpPrice = signal.signal_type === 'BUY'
                                                ? signal.entry_price * (1 + tp.level / 100)
                                                : signal.entry_price * (1 - tp.level / 100);
                                            // Ensure this matches the format in your JSON, e.g., "tp_07" for 0.7, "tp_12" for 1.2
                                            const activatedTpLevelKey = `tp_${String(tp.level).replace('.', '')}`;
                                            const isTPReached = signal.activated_tp_levels && signal.activated_tp_levels.includes(activatedTpLevelKey);
                                            
                                            return `
                                                <tr class="${isTPReached ? 'tp-achieved' : ''}">
                                                    <td>${formatNumber(tp.level, 1)}</td>
                                                    <td>${formatNumber(tpPrice, 4)}</td>
                                                    <td>${formatPercentage(tp.level)}</td>
                                                    <td>${isTPReached ? 'Yes' : 'No'}</td>
                                                    <td>${tp.close_percentage > 0 ? tp.close_percentage + '%' : '0%'}</td>
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>
                            <div class="chart-container" id="chart-${signal.signal_id}"></div>
                        `;
                        dateSignalsDiv.appendChild(signalCard);

                        // Render TradingView chart
                        if (signal.symbol) {
                            createChart(signal, `chart-${signal.signal_id}`);
                        } else {
                            console.warn(`Cannot create chart for signal ${signal.signal_id}: Symbol is missing.`);
                            document.getElementById(`chart-${signal.signal_id}`).innerHTML = '<p class="text-center text-gray-500">Chart not available (symbol missing).</p>';
                        }
                    });
                }
                detailsElement.appendChild(dateSignalsDiv);
                signalsContainer.appendChild(detailsElement);
            }
        }

        // Initial fetch and render
        document.addEventListener('DOMContentLoaded', async () => {
            const signals = await fetchSignals();
            updateSummaryStatistics(signals);
            renderSignals(signals);

            // Set up interval for refreshing data every 5 minutes (300000 milliseconds)
            setInterval(async () => {
                const updatedSignals = await fetchSignals();
                updateSummaryStatistics(updatedSignals);
                renderSignals(updatedSignals);
            }, 300000);
        });
    </script>
</body>
</html>
